\subsection{eMoflon}
\label{sec:eMoflon}

\NOTE{\emph{Solution expert:} Tony, \emph{Interviewer:} Bernhard}

\emph{eMoflon} \cite{Leblebici2014a} applies triple graph grammars in the technological space of EMF.
Models are viewed as graphs, where objects and links are represented by nodes and edges, respectively.
A correspondence graph is maintained in between the source and the target graph to keep track of the relationships between source and target elements.
Consistency is specified declaratively by providing a \emph{triple graph grammar} (TGG) \cite{Schurr1994}.
A TGG consists of a \emph{schema}, which defines types of correspondences to be maintained in the correspondence graph, and a set of \emph{(triple) rules}. Each rule describes a synchronous extension of the whole triple graph. Rules are monotonic, i.e., they add nodes and edges, but they do not delete them. Together with a start graph (which is assumed to be empty in eMoflon), triple rules constitute a graph grammar which generates consistent triple graphs, i.e., triples of mutually consistent source, correspondence, and target graphs.

From synchronous triple rules, \emph{directed rules} are automatically derived.
A directed rule assumes that a local extension has been performed on the master graph, and propagates this extension to the correspondence graph and the dependent graph.
To perform a directed synchronization, either forward or backward rules are applied, depending on the requested transformation direction.
To restore consistency, all rule applications that were invalidated by changes made to the master graph (the graph that has been modified last) are revoked in a first ``rollback'' phase.
In a second ``translation'' phase, directed rules are applied such that the resulting triple graph is consistent according to the TGG, i.e., the triple graph could also have been generated from the start graph by applying synchronous TGG rules.   

\subsubsection{Classification}
\label{sec:ClassificationEMoflon}

eMoflon operates in a \emph{propagation-based} style: As input, the tool thus expects old versions of the master, dependent, and correspondence graphs, as well as a structural delta between the old and the new versions of the master graph.
The tool architecture is thus classified as \emph{s-delta-corr-based} (see the right-hand side of figure~\ref{fig:deltaCorrBased}).
eMoflon derives both \emph{fUP} and \emph{bUP} automatically from the TGG, and uses these functions to propagate the structural delta from the master to the correspondence and dependent models.
Each TGG rule can be viewed as a connected pair of a source and target edit, describing an infinite set of paired source and target deltas produced by these edits.
With this in mind, deriving \emph{fUP} from a TGG is fairly straightforward: every input source delta is decomposed into a sequence of smaller source deltas that can be induced by a corresponding sequence of source edits from TGG rules.
Once this sequence of required source edits has been computed, each source edit is propagated to the target edit specified by the corresponding TGG rule.
The derived sequence of target edits is applied to the target model to produce a target delta as output of \emph{fUP} (deriving \emph{bUP} works analogously).

eMoflon guarantees \emph{correctness}: After a directed synchronization, a triple graph is obtained that  is guaranteed to be a member of the language generated by the TGG.
Under certain conditions that can be mapped to required properties of the underlying TGG, eMoflon also guarantees \emph{completeness}: Every structural delta that results in a master model for which a consistent triple exists, can be successfully propagated to the correspondence and dependent model.
While such totality guarantees are often ignored in formal frameworks, practical instantiations of these frameworks tend to implement \emph{partial} consistency restoration.
For instance, although the \emph{put} and \emph{get} functions for BiGUL can fail in general, this is not regarded as a violation of the round-trip laws.

In eMoflon, the \emph{consistency relation} is defined \emph{explicitly} by a \emph{grammar} that generates consistent triple graphs.
\emph{Synchronization} is controlled \emph{implicitly}, as directed rules for consistency restoration are derived under the hood.
eMoflon currently supports only \emph{directed} synchronization.
Finally, eMoflon is designed mainly for \emph{on-demand} and \emph{automatic} synchronization.

\subsubsection{Benchmark solution with eMoflon}
\label{sec:solutionEMoflon}

\lstdefinelanguage{emoflon}{
	morekeywords = {using,abstract,rule,with,source,target,correspondence,src,trg,attributeConditions,extends},
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/}
}

The benchmark solution is composed of a graph schema and a set of triple rules.
The \emph{graph schema} (not shown) defines two types of correspondence nodes for relationships between family and person registers, as well as between family members and persons, respectively. Each correspondence node is linked to exactly one node in the families graph and one node in the persons graph, respectively.
%
The \emph{rule set} consists of one rule for creating and relating family and person registers, and a set of rules for creating family members and persons.
In principle, eight rules could be specified independently from each other for covering all cases with respect to the roles of family members, and the creation of a new or the reuse of an existing family.
As this would result in highly redundant rules with many copies of rule elements, however, eMoflon supports \emph{rule inheritance} that can be used to factor out common rule elements into abstract superrules. 

\begin{lstlisting}[label={lst:emoflonFamilyMember2Person}, float=bt!, language=emoflon, caption={Mapping family members to persons}]
#abstract #rule FamilyMember2Person 
          #with FamiliesToPersons

#source { 
    families : FamilyRegister {
        ++ -families->f
    }
    ++ f : Family
    ++ fm : FamilyMember
}

#target {
    persons : PersonRegister {
        ++ -persons->p
    }
    ++ p : Person
}

#correspondence {
    families2persons : FamiliesToPersonsCorr {
        #src->families
        #trg->persons
    }
    ++ member2Persons : FamilyMemberToPerson {
        #src->fm
        #trg->p
    }
}

#attributeConditions {
    concat(", ", f.name, fm.name, p.name)
}
\end{lstlisting}


Listing~\ref{lst:emoflonFamilyMember2Person} depicts an \emph{abstract rule} which serves as root of the inheritance hierarchy.
As TGGs are often regarded as a predominantly \emph{visual} language, eMoflon also supports a read-only visualisation for TGGs rules.  
To simplify comparison to all other bx languages evaluated in this paper, however, a \emph{textual} concrete syntax is used here to represent and discuss TGG rules.

A rule which is designated as abstract is not applied as such, but (eventually) needs to be refined by \emph{concrete} rules.
The \code{with} clause on line~2 refers to the underlying TGG schema.
The triple rule is composed of three parts, indicated by the keywords \code{source}, \code{target}, and \code{correspondence}, respectively. The rule requires the presence of a family register (line~5), a person register (line~13), and a correspondence (line~20) which is linked to the family register in the source graph and the person register in the target graph. Nodes and edges to be created are decorated with a \code{++} qualifier. In the source graph, a family is created along with an incoming edge from the family register; in addition, a family member is created. In the target graph, a person is created and linked to the person register. The family member and the person are connected by a correspondence to be added to the correspondence graph (line~24).
Finally, the attribute condition (line~31) specifies that the name of the person is composed from the family name and the first name of the family member.

\begin{lstlisting}[label={lst:emoflonExistingFamily2Person}, float=tb!, language=emoflon, caption={Mapping members in existing families to persons}]
#abstract #rule ExistingFamily2Person 
          #extends FamilyMember2Person 
          #with FamiliesToPersons

#source { 
    families : FamilyRegister {
        -families->f
    }
    f : Family
}
\end{lstlisting}

The abstract rule in listing~\ref{lst:emoflonFamilyMember2Person} creates a family together with a family member.
This rule is refined by another abstract rule which assumes that a suitable family already exists (listing~\ref{lst:emoflonExistingFamily2Person}).
The subrule inherits all elements from its superrule, but redefines the binding state (removes the \code{++}) of the family node (line~9) and its incoming edge (line~7).

\begin{lstlisting}[label={lst:emoflonDaughterToFemale}, float=tb!, language=emoflon, caption={Mapping daughters to female persons}]
#rule DaughterToFemale 
#extends FamilyMember2Person 
#with FamiliesToPersons

#source { 
    ++ f : Family {
        ++ -daughters->fm
    }
    ++ fm : FamilyMember
}

#target {
    ++ p : Female
}
\end{lstlisting}

Listing~\ref{lst:emoflonDaughterToFemale} shows one out of four concrete rules for mapping family members in new families to persons.
The rule adds the edge between the family and the member, which has been missing so far (line~7), and redefines the type of the person from \code{Person} to \code{Female}.

\begin{lstlisting}[label={lst:emoflonDaughterOfExistingFamilyToFemale}, float=tb!, language=emoflon, caption={Mapping daughters in existing families to females}]
#rule DaughterOfExistingFamilyToFemale
#extends ExistingFamily2Person, DaughterToFemale
#with FamiliesToPersons
\end{lstlisting}

Listing~\ref{lst:emoflonDaughterOfExistingFamilyToFemale} demonstrates the use of \emph{multiple inheritance}: The rule for creating a daughter in an existing family as well as well as a female person is obtained by extending both the abstract rule for mapping members in existing families to persons (Listing~\ref{lst:emoflonExistingFamily2Person}) and the concrete rule for mapping daughters in new families to females (Listing~\ref{lst:emoflonDaughterToFemale}).
Conflicts are resolved by favoring ``context over create'' (black over green).
This means that subrules are allowed to extend the precondition of their superrules but never reduce it.
The family node \code{f} in \code{DaughterOfExistingFamiltyToFemale} thus obtains its binding state from the rule \code{ExistingFamily2Person}.

As presented so far, the backward transformation would behave \emph{non-deterministically}. To obtain a \emph{configurable backward transformation}, controlled by configuration parameters, the set of applicable alternatives for a given match in the persons graph is constrained dynamically according to the current setting of configuration parameters.
For example, if children are preferred in new families, mappings of a person to a parent as well as to a child in an existing family are disabled.
As the TGG language does not offer any control structures, the configurability of the backward transformation is realized as an additional Java program that communicates with the transformation engine via an API. 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
