\subsection{eMoflon}
\label{sec:eMoflon}

\NOTE{\emph{Solution expert:} Tony, \emph{Interviewer:} Zinovy}

\emph{eMoflon} \cite{Leblebici2014a} applies triple graph grammars in the technological space of EMF. Models are considered as graphs, where objects and links are represented by nodes and edges, respectively. A correspondence graph is placed in between the source and the target graph to keep track of the relationships between source and target elements. In contrast to BXtend, synchronization is specified declaratively by a \emph{triple graph grammar} (TGG) \cite{Schurr1994}. A TGG consists of a \emph{schema}, which defines types of correspondences to be maintained in the correspondence graph, and a set of \emph{(triple) rules}. Each rule describes a synchronous extension of the whole triple graph. Rules are monotonic, i.e., they add nodes and edges, but they do not delete them. Together with a start graph (which is assumed to be empty in eMoflon), triple rules constitute a graph grammar which generates consistent triple graphs, i.e., triples of mutually consistent source, correspondence, and target graphs.

From synchronous triple rules, \emph{directed rules} are derived transparently to the user of eMoflon. A directed rule assumes that a local extension has been performed on the master graph, and propagates this extension to the correspondence graph and the dependent graph. To perform directed synchronizations, either forward or backward rules are applied, depending on the requested transformation direction. To restore consistency, all rules which are broken due to changes to the master graph (the graph which has been modified) are revoked in a first phase. In a second phase, directed rules are applied such that the resulting triple graph is consistent according to the TGG (i.e., the triple graph could have been generated from the start graph by applying synchronous TGG rules).   

\subsubsection{Classification}
\label{sec:ClassificationEMoflon}

eMoflon operates in a \emph{propagation-based} style: As inputs, the tool expects old versions of the participating graphs, as well as a structural delta between the old and the new version of the master graph. Based on these inputs, updates are propagated to the dependent graph, as well as to the correspondence graph. Thus, the tool architecture is classified as \emph{delta-corr-based} (see right-hand side of Figure~\ref{fig:deltaCorrBased}). 

Under certain conditions referring to the underlying TGG, eMoflon guarantees \emph{correctness}: After a directed synchronization, a triple graph is obtained which is a member of the language generated by the TGG. eMoflon also guarantees \emph{stability}: If an update is performed to the master graph which does not destroy the consistency relation, the dependent graph will remain untouched. However, hippocraticness is not guaranteed: The delta records the changes which have been actually applied, and propagates these changes. For example, if a family member is deleted and re-inserted, the corresponding person will be deleted and re-inserted accordingly, implying that the birthday of the respective person will get lost. I.e., although a consistent triple graph could be produced by leaving the dependent graph untouched and modifying only the correspondence graph, both the correspondence graph and the dependent graph are modified to restore consistency. 

In eMoflon, the \emph{consistency relation} is defined \emph{explicitly} by a \emph{grammar} which generates consistent triple graphs. \emph{Synchronization} is controlled \emph{implicitly}, since directed rules for consistency restoration are derived under the hood. eMoflon supports \emph{directed synchronization on demand}. Finally, synchronization may be performed either \emph{automatically} or \emph{interactively}. In the Families to Persons benchmark, synchronization is an automatic process because the backward transformation is controlled through configuration parameters. However, it is also possible to perform synchronization interactively in cases where non-determinism should be resolved by user decisions at runtime.

\subsubsection{Benchmark solution with eMoflon}
\label{sec:solutionEMoflon}

\lstdefinelanguage{emoflon}{
	morekeywords = {using,abstract,rule,with,source,target,correspondence,src,trg,attributeConditions,extends},
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/}
}

The benchmark solution is composed of a graph schema and a set of triple rules. The \emph{graph schema} (which is omitted here) defines two types of correspondence nodes for relationships between family and person registers, as well as between family members and persons, respectively. Each correspondence node is linked to exactly one node in the families graph and one node in the persons graph, respectively.

The \emph{rule set} consists of one rule for creating and relating family and person registers, and a set of rules for creating family members and persons. In principle, eight rules could be specified independently from each other for covering all cases with respect to the roles of family members and the creation of a new or the reuse of an existing family. However, this would result in highly redundant rules with many copies of rule elements. There, \emph{rule inheritance} is applied to factor out common rule elements into abstract superrules.  

\begin{lstlisting}[label={lst:emoflonFamilyMember2Person}, float=htb!, language=emoflon, caption={Mapping family members to persons}]
#abstract #rule FamilyMember2Person 
    #with FamiliesToPersons

#source { 
    families : FamilyRegister {
        ++ -families->f
    }
    ++ f : Family
    ++ fm : FamilyMember
}

#target {
    persons : PersonRegister {
        ++ -persons->p
    }
    ++ p : Person
}

#correspondence {
    families2persons : FamiliesToPersonsCorr {
        #src->families
        #trg->persons
    }
    ++ member2Persons : FamilyMemberToPerson {
        #src->fm
        #trg->p
    }
}

#attributeConditions {
    concat(", ", f.name, fm.name, p.name)
}
\end{lstlisting}


Listing~\ref{lst:emoflonFamilyMember2Person} shows an \emph{abstract rule} which serves as root of the inheritance hierarchy. A rule which is designated as abstract is not applied as such, but (eventually) needs to be refined by \emph{concrete} rules. The \code{with} clause in line~2 refers to the underlying graph schema. The triple rule is composed of three parts, indicated by the keywords \code{source}, \code{target}, and \code{correspondence}, respectively. The rule requires the presence of a family register (line~5), a person register (line~13), and a correspondence (line~20) which is linked to the family register in the source graph and the person register in the target graph. Nodes and edges to be created are decorated with a \code{++} qualifier. In the source graph, a family is created along with an incoming edge from the family register; in addition, a family member is created. In the target graph, a person is created and linked to the person register. The family member and the person are connected by a correspondence to be added to the correspondence graph (line~24). Finally, the attribute condition (line~31) specifies that the name of the person is composed from the family name and the first name of the family member.

\begin{lstlisting}[label={lst:emoflonExistingFamily2Person}, float=htb!, language=emoflon, caption={Mapping members in existing families to persons}]
#abstract #rule ExistingFamily2Person 
    #extends FamilyMember2Person 
    #with FamiliesToPersons

#source { 
    families : FamilyRegister {
        -families->f
    }
    f : Family
}
\end{lstlisting}

The abstract rule in Listing~\ref{lst:emoflonFamilyMember2Person} creates a family along with a family member. This rule is refined by another abstract rule which assumes an already  existing family (Listing~\ref{lst:emoflonExistingFamily2Person}). The subrule inherits all elements from its superrule, but redefines the binding state of the family node (line~9) and its incoming edge (line~7).

\begin{lstlisting}[label={lst:emoflonDaughterToFemale}, float=htb!, language=emoflon, caption={Mapping daughters to female persons}]
#rule DaughterToFemale 
    #extends FamilyMember2Person 
    #with FamiliesToPersons

#source { 
    ++ f : Family {
        ++ -daughters->fm
    }
    ++ fm : FamilyMember
}

#target {
    ++ p : Female
}
\end{lstlisting}

Listing~\ref{lst:emoflonDaughterToFemale} shows one out of four concrete rules for mapping family members in new families to persons. The rule adds the edge between the family node and the member node, which has been missing so far (line~7), and redefines the type of the person node from \code{Person} to \code{Female}.

\begin{lstlisting}[label={lst:emoflonDaughterOfExistingFamilyToFemale}, float=htb!, language=emoflon, caption={Mapping daughters in existing families to female persons}]
#rule DaughterOfExistingFamilyToFemale 
    #extends 
        ExistingFamily2Person, DaughterToFemale 
    #with FamiliesToPersons
\end{lstlisting}

Listing~\ref{lst:emoflonDaughterOfExistingFamilyToFemale} demonstrates the use of \emph{multiple inheritance}: The rule for creating a daughter in an existing family as well as well as a female person is obtained by extending both the abstract rule for mapping members in existing families to persons (Listing~\ref{lst:emoflonExistingFamily2Person}) and the concrete rule for mapping daughters in new families to females (Listing~\ref{lst:emoflonDaughterToFemale}). Please note that conflicts are resolved in favor of the first rule in the list of superrules. Thus, the family node \code{f} obtains its binding state from the rule \code{ExistingFamily2Person}.

As presented so far, the backward transformation would behave \emph{non-deterministically}. To obtain a \emph{configurable backward transformation}, controlled by configuration parameters, the set of applicable alternatives for a given match in the persons graph is constrained dynamically according to the current setting of configuration parameters. For example, if children are preferred in new families, mappings of a person to a parent as well as to a child in an existing family are disabled. Since the TGG language does not offer any control structures, the configurability of the backward transformation is realized by Java code, outside the definition of the triple graph grammar.

